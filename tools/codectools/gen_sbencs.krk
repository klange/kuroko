import json, fileio
from itertools import enumerate

let indices
with fileio.open("tools/codectools/indexes.json") as f:
    indices = json.loads(f.read())

def build_sbmap(name):
    if name == "iso-8859-8-i":
        name = "iso-8859-8"
    let encoding_map = {}
    let decoding_map = {}
    for n, i in enumerate(indices[name]):
        if i != None:
            decoding_map[n + 0x80] = i
            encoding_map[i] = n + 0x80
    return (encoding_map, decoding_map)

let template = """
class {idname}IncrementalEncoder(AsciiIncrementalEncoder):
    name = {mainlabel}
    html5name = {weblabel}
    encoding_map = {encode}

class {idname}IncrementalDecoder(AsciiIncrementalDecoder):
    name = {mainlabel}
    html5name = {weblabel}
    decoding_map = {decode}

register_kuroko_codec(
    {labels}, 
    {idname}IncrementalEncoder, 
    {idname}IncrementalDecoder)
"""

let boilerplate = """# Generated by tools/codectools/gen_sbencs.krk from WHATWG encodings.json and indexes.json

from codecs.infrastructure import AsciiIncrementalEncoder, AsciiIncrementalDecoder, register_kuroko_codec
"""

# Places where the WHATWG encoding "name" is actually the name of a similar encoding aliased
#   together. Granted, this is not very common for single byte encodings (only "KOI8-U" being
#   KOI8-RU comes to mind, since e.g. Windows-1252 is named Windows-1252 with "ISO-8859-1"
#   merely an alias) but it is, importantly, the rule rather than the exception for the CJK
#   codecs (e.g. Windows-31J is an alias of "Shift JIS" which is actually Windows-31J).
let realname = {"koi8-u": "koi8-ru"}

# Additional labels included for Python parity
let parity_labels = {
    "windows-1250": ["1250"],
    "windows-1251": ["1251"],
    # I've assigned several of Python's aliases to the ecma-43-dv codec, but these are minor
    #   misspellings of one WHATWG assigns for Windows-1252, so doing likewise to avoid confusion.
    "windows-1252": ["ansi-x3-4-1968", "ansi-x3.4-1986", "1252"],
    "windows-1253": ["1253"],
    "windows-1254": ["1254", "iso-8859-9-1989"],
    "windows-1255": ["1255"],
    "windows-1256": ["1256"],
    "windows-1257": ["1257"],
    "windows-1258": ["1258"],
    "iso-8859-2": ["iso-8859-2-1987"],
    "iso-8859-3": ["iso-8859-3-1988"],
    "iso-8859-4": ["iso-8859-4-1988"],
    "iso-8859-5": ["iso-8859-5-1988"],
    "iso-8859-6": ["iso-8859-6-1987"],
    "iso-8859-7": ["iso-8859-7-1987"],
    "iso-8859-8": ["iso-8859-8-1988"],
    "iso-8859-10": ["iso-8859-10-1992"],
    # Note Python differentiates TIS-620 and ISO-8859-11 for some reason (neither IANA nor WHATWG
    #   do). Also, it aliases "iso-ir-166" to the former (since it cites TIS-620) despite it having
    #   an NBSP in the registration document (case in point).
    "windows-874": ["iso-8859-11-2001", "tis620", "tis-620-0", "tis-620-2529-0",
                    "tis-620-2529-1", "iso-ir-166", "thai"],
    "iso-8859-13": ["l7", "latin7"], 
    "iso-8859-14": ["iso-8859-14-1998", "l8", "latin8", "iso-ir-199", "iso_celtic"], 
    "iso-8859-15": ["latin9"], 
    "iso-8859-16": ["iso-8859-16-2001", "iso8859-16", "l10", "latin10", "iso-ir-226"], 
    "macintosh": ["mac-roman", "macroman"], 
    "x-mac-cyrillic": ["mac-cyrillic", "maccyrillic"],
}

let encode_xudef = {}
let decode_xudef = {}
for i in range(128):
    let codepoint = 0xF780 + i
    let byte = 0x80 + i
    encode_xudef[codepoint] = byte
    decode_xudef[byte] = codepoint

with fileio.open("modules/codecs/sbencs.krk", "w") as outf:
    outf.write(boilerplate)
    with fileio.open("tools/codectools/encodings.json") as f:
        for i in json.loads(f.read()):
            if i["heading"] == "Legacy single-byte encodings":
                for enc in i["encodings"]:
                    let whatwgname = enc["name"].lower()
                    let name = realname.get(whatwgname, whatwgname)
                    let labels = enc["labels"]
                    if name in parity_labels:
                        labels.extend(parity_labels[name])
                    let built = build_sbmap(whatwgname)
                    let encoding_map = built[0]
                    let decoding_map = built[1]
                    let idname = name.title().replace("-", "")
                    outf.write(template.format(mainlabel=repr(name), encode=repr(encoding_map),
                            weblabel=repr(whatwgname),
                            decode=repr(decoding_map), labels=repr(labels), idname=idname))
    outf.write(template.format(mainlabel=repr("x-user-defined"), encode=repr(encode_xudef),
            weblabel=repr("x-user-defined"),
            decode=repr(decode_xudef), labels=repr(["x-user-defined"]), idname="XUserDefined"))









