import json, fileio

let indices
with fileio.open("tools/codecs/indexes.json") as f:
    indices = json.loads(f.read())

class enumerate():
    def __init__(iterable):
        if '__iter__' not in dir(iterable):
            raise TypeError(f'{iterable} is not iterable')
        self.i = 0
        self.iterable = iterable
    def __iter__():
        let i = self.i
        let iter = self.iterable.__iter__()
        def _():
            let next = iter()
            let out = (i, next) if next is not iter else _
            i++
            return out
        return _

def build_sbmap(name):
    if name == "iso-8859-8-i":
        name = "iso-8859-8"
    let encoding_map = {}
    let decoding_map = {}
    for n, i in enumerate(indices[name]):
        if i != None:
            decoding_map[n + 0x80] = i
            encoding_map[i] = n + 0x80
    return (encoding_map, decoding_map)

let template = """
class {idname}IncrementalEncoder(AsciiIncrementalEncoder):
    name = {mainlabel}
    webname = {weblabel}
    encoding_map = {encmap}

class {idname}IncrementalDecoder(AsciiIncrementalDecoder):
    name = {mainlabel}
    webname = {weblabel}
    decoding_map = {decmap}

register_kuroko_codec(
    {labels}, 
    {idname}IncrementalEncoder, 
    {idname}IncrementalDecoder)
"""

let boilerplate = """# Generated by tools/codecs/gen_sbencs.krk from WHATWG encodings.json and indexes.json

from codecs.infrastructure import AsciiIncrementalEncoder, AsciiIncrementalDecoder, register_kuroko_codec
"""

# Places where the WHATWG encoding "name" is actually the name of a similar encoding aliased
#   together. Granted, this is not very common for single byte encodings (only "KOI8-U" being
#   KOI8-RU comes to mind, since e.g. Windows-1252 is named Windows-1252 with "ISO-8859-1"
#   merely an alias) but it is, importantly, the rule rather than the exception for the CJK
#   codecs (e.g. Windows-31J is an alias of "Shift JIS" which is actually Windows-31J).
let realname = {"koi8-u": "koi8-ru"}

let encode_xudef = {}
let decode_xudef = {}
for i in range(128):
    let codepoint = 0xF780 + i
    let byte = 0x80 + i
    encode_xudef[codepoint] = byte
    decode_xudef[byte] = codepoint

with fileio.open("modules/codecs/sbencs.krk", "w") as outf:
    outf.write(boilerplate)
    with fileio.open("tools/codecs/encodings.json") as f:
        for i in json.loads(f.read()):
            if i["heading"] == "Legacy single-byte encodings":
                for enc in i["encodings"]:
                    let whatwgname = enc["name"].lower()
                    let name = realname.get(whatwgname, whatwgname)
                    let labels = enc["labels"]
                    let built = build_sbmap(whatwgname)
                    let encoding_map = built[0]
                    let decoding_map = built[1]
                    let idname = name.title().replace("-", "")
                    outf.write(template.format(mainlabel=repr(name), encmap=repr(encoding_map),
                            weblabel=repr(whatwgname),
                            decmap=repr(decoding_map), labels=repr(labels), idname=idname))
    outf.write(template.format(mainlabel=repr("x-user-defined"), encmap=repr(encode_xudef),
            weblabel=repr("x-user-defined"),
            decmap=repr(decode_xudef), labels=repr(["x-user-defined"]), idname="XUserDefined"))









