import json
import fileio
from itertools import enumerate

let indices
with fileio.open('tools/codecs/indexes.json') as f:
    indices = json.loads(f.read())

let aliases = {}

with fileio.open('tools/codecs/encodings.json') as f:
    for i in json.loads(f.read()):
        if i['heading'].startswith('Legacy multi-byte'):
            for enc in i['encodings']:
                aliases[enc['name'].lower()] = enc['labels']

let boilerplate = '''# Generated by tools/codecs/gen_dbdata.krk from WHATWG encodings.json and indexes.json

from codecs.infrastructure import AsciiIncrementalEncoder, AsciiIncrementalDecoder, register_kuroko_codec
'''

let template = '''
class {idname}IncrementalEncoder(AsciiIncrementalEncoder):
    name = {mainlabel}
    webname = {weblabel}
    encoding_map = {encmap}

class {idname}IncrementalDecoder(AsciiIncrementalDecoder):
    name = {mainlabel}
    webname = {weblabel}
    decoding_map = {decmap}
    dbrange = {dbrange}
    tbrange = {tbrange}
    trailrange = {trailrange}

register_kuroko_codec({labels}, {idname}IncrementalEncoder, {idname}IncrementalDecoder)
'''

let template_big5 = '''
class {idnameenc}IncrementalEncoder(AsciiIncrementalEncoder):
    name = {mainlabelenc}
    webname = {weblabel}
    encoding_map = {encmap}

class {idnameenc2}IncrementalEncoder(AsciiIncrementalEncoder):
    name = {mainlabelenc2}
    webname = None
    encoding_map = {encmap2}

class {idnamedec}IncrementalDecoder(AsciiIncrementalDecoder):
    name = {mainlabeldec}
    webname = {weblabel}
    decoding_map = {decmap}
    dbrange = {dbrange}
    tbrange = {tbrange}
    trailrange = {trailrange}

# Our Big5 deviates from WHATWG somewhat here in that encoding to HKSCS is permitted if
# specifically the HKSCS label is specified, otherwise Big5-ETEN is used. This seems more
# sensible in a non-browser context than the WHATWG behaviour of the encoder behaving the
# same for all labels.
register_kuroko_codec({labels}, {idnameenc}IncrementalEncoder, {idnamedec}IncrementalDecoder)
register_kuroko_codec({labels2}, {idnameenc2}IncrementalEncoder, {idnamedec}IncrementalDecoder)
'''

let decode_eucjp = {}
let decode_shiftjis = {}
let decode_jis7 = {}
let decode_jis7katakana = {}
let decode_uhc = {}
let decode_big5eten = {}
let decode_big5hkscs = {}
let decode_gbk = {}
let encode_eucjp = {}
let encode_shiftjis = {}
let encode_jis7 = {}
let encode_uhc = {}
let encode_big5eten = {}
let encode_big5web = {}
let encode_big5hkscs = {}
let encode_gbk = {}
let dbrange_eucjp = tupleOf(0x8E, *range(0xA1, 0xFE + 1))
let dbrange_shiftjis = tupleOf(*range(0x81, 0x9F + 1), *range(0xE0, 0xFC + 1))
let dbrange_uhc = tupleOf(*range(0x81, 0xFE + 1))
let dbrange_big5 = tupleOf(*range(0x81, 0xFE + 1))
let tbrange_eucjp = (0x8F,)
let tbrange_shiftjis = ()
let tbrange_uhc = ()
let tbrange_big5 = ()
let trailrange_eucjp = tupleOf(*range(0xA1, 0xFE + 1))
let trailrange_shiftjis = tupleOf(*range(0x40, 0x7E + 1), *range(0x80, 0xFC + 1))
let trailrange_uhc = tupleOf(*range(0x41, 0xFE + 1)) # As WHATWG define it (a superset of the actual range)
let trailrange_big5 = tupleOf(*range(0x40, 0x7E + 1), *range(0xA1, 0xFE + 1))

for pointer, ucs in enumerate(indices['jis0208']):
    if ucs == None: continue
    let sku   = (pointer / 188) + 1
    let sten  = (pointer % 188) + 1
    let first = 0x80 + sku
    if first >= 0xA0: first += 0x40
    let second = 0x3F + sten
    if second >= 0x7F: second += 1
    decode_shiftjis[(first,second)] = ucs
    if ucs not in encode_shiftjis and not (8272 <= pointer and pointer <= 8835):
        encode_shiftjis[ucs] = (first, second)
    let ku  = (pointer / 94) + 1
    let ten = (pointer % 94) + 1
    if ku <= 94:
        let firste  = 0xA0 + ku
        let seconde = 0xA0 + ten
        decode_eucjp[(firste,seconde)] = ucs
        encode_eucjp[ucs] = (firste,seconde)
        let first7  = 0x20 + ku
        let second7 = 0x20 + ten
        decode_jis7[(first7,second7)] = ucs
        encode_jis7[ucs] = (first7, second7)

for pointer, ucs in enumerate(indices['jis0212']):
    if ucs == None: continue
    let ku  = (pointer / 94) + 1
    let ten = (pointer % 94) + 1
    let second = 0xA0 + ku
    let third  = 0xA0 + ten
    decode_eucjp[(0x8F,second,third)] = ucs

for i in range(63):
    let ucs  = 0xFF61 + i
    let byte = 0xA1 + i
    decode_shiftjis[byte] = ucs
    encode_shiftjis[ucs] = byte
    decode_eucjp[(0x8E, byte)] = ucs
    encode_eucjp[ucs] = (0x8E, byte)
    decode_jis7katakana[0x21 + i] = ucs
    encode_jis7[ucs] = encode_jis7[indices['iso-2022-jp-katakana'][i]]

for i in range(94 * 20):
    let pointer = 8836 + i
    let ucs     = 0xE000 + i
    let sku     = (pointer / 188) + 1
    let sten    = (pointer % 188) + 1
    let first   = 0xC0 + sku
    let second  = 0x3F + sten
    if second >= 0x7F: second += 1
    decode_shiftjis[(first,second)] = ucs

for pointer, ucs in enumerate(indices['euc-kr']):
    if ucs == None: continue
    let uku  = (pointer / 190) + 1
    let uten = (pointer % 190) + 1
    let first  = 0x80 + uku
    let second = 0x40 + uten
    decode_uhc[(first,second)] = ucs
    encode_uhc[ucs] = (first,second)

for pointer, ucs in enumerate(indices['gb18030']):
    if ucs == None: continue
    let uku  = (pointer / 190) + 1
    let uten = (pointer % 190) + 1
    let first  = 0x80 + uku
    let second = 0x3F + uten
    if second >= 0x7F: second += 1
    decode_gbk[(first,second)] = ucs
    if ucs not in encode_gbk:
        encode_gbk[ucs] = (first,second)

for pointer, ucs in enumerate(indices['big5']):
    if ucs == None: continue
    let bku  = (pointer / 157) + 1
    let bten = (pointer % 157) + 1
    let first  = 0x80 + bku
    let second = 0x3F + bten
    if second >= 0x7F: second += 0x22
    decode_big5hkscs[(first, second)] = ucs
    if pointer < 5024:
        encode_big5hkscs[ucs] = (first, second)
    else if pointer < 18997:
        decode_big5eten[(first, second)] = ucs
        if ucs not in encode_big5eten or ucs in [0x2550, 0x255E, 0x2561, 0x256A, 0x5341, 0x5345]:
            encode_big5hkscs[ucs] = (first, second)
            encode_big5web[ucs] = (first, second)
            encode_big5eten[ucs] = (first, second)
    else:
        if ucs not in encode_big5hkscs:
            encode_big5hkscs[ucs] = (first, second)
        if ucs not in encode_big5web:
            encode_big5web[ucs] = (first, second)

encode_shiftjis[0xA5] = (encode_eucjp[0xA5] = 0x5C)
encode_shiftjis[0x203E] = (encode_eucjp[0x203E] = 0x7E)
encode_shiftjis[0x2212] = encode_shiftjis[0xFF0D]
encode_eucjp[0x2212] = encode_eucjp[0xFF0D]
encode_jis7[0x2212] = encode_jis7[0xFF0D]
decode_big5hkscs[(0x88, 0x62)] = (0xCA, 0x304)
decode_big5hkscs[(0x88, 0x64)] = (0xCA, 0x30C)
decode_big5hkscs[(0x88, 0xA3)] = (0xEA, 0x304)
decode_big5hkscs[(0x88, 0xA5)] = (0xEA, 0x30C)
decode_gbk[0x80] = 0x20AC

with fileio.open('modules/codecs/dbdata.krk', 'w') as f:
    f.write(boilerplate)
    f.write(template.format(
        mainlabel=repr('windows-31j'),
        weblabel=repr('shift_jis'),
        labels=repr(aliases['shift_jis']),
        encmap=repr(encode_shiftjis), decmap=repr(decode_shiftjis), idname='Windows31J',
        dbrange=repr(dbrange_shiftjis), tbrange=repr(tbrange_shiftjis),
        trailrange=repr(trailrange_shiftjis)))
    f.write(template.format(
        mainlabel=repr("x-euc-jp"),
        weblabel=repr("euc-jp"),
        labels=repr(aliases["euc-jp"]),
        encmap=repr(encode_eucjp), decmap=repr(decode_eucjp), idname="XEucJp",
        dbrange=repr(dbrange_eucjp), tbrange=repr(tbrange_eucjp), 
        trailrange=repr(trailrange_eucjp)))
    f.write(template.format(
        mainlabel=repr("windows-949"), 
        weblabel=repr("euc-kr"),
        labels=repr(aliases["euc-kr"]),
        encmap=repr(encode_uhc), decmap=repr(decode_uhc), idname="Windows949",
        dbrange=repr(dbrange_uhc), tbrange=repr(tbrange_uhc), 
        trailrange=repr(trailrange_uhc)))
    f.write(template_big5.format(
        mainlabelenc=repr("big5-eten"), 
        mainlabelenc2=repr("big5-hkscs"), 
        mainlabeldec=repr("big5-hkscs"), 
        weblabel=repr("big5"),
        labels=repr(["big5", "cn-big5", "csbig5", "x-x-big5", "big5-eten"]),
        labels2=repr(["big5-hkscs", "big5hkscs"]),
        encmap=repr(encode_big5eten), idnameenc="Big5Eten",
        encmap2=repr(encode_big5hkscs), idnameenc2="Big5Hkscs",
        decmap=repr(decode_big5hkscs), idnamedec="Big5Hkscs",
        dbrange=repr(dbrange_big5), tbrange=repr(tbrange_big5), 
        trailrange=repr(trailrange_big5)))
    f.write("\n# Additional data for bespoke codecs")
    f.write("\nlet encode_jis7 = {}".format(repr(encode_jis7)))
    f.write("\nlet decode_jis7 = {}".format(repr(decode_jis7)))
    f.write("\nlet decode_jis7katakana = {}".format(repr(decode_jis7katakana)))
    f.write("\nlet encode_gbk = {}".format(repr(encode_gbk)))
    f.write("\nlet decode_gbk = {}".format(repr(decode_gbk)))
    let ranges = indices["gb18030-ranges"]
    let rangesout = []
    for i in ranges:
        rangesout.append((i[0], i[1]))
    f.write("\nlet gb_surrogate_ranges = {}".format(repr(rangesout)))


