from codecs.infrastructure import register_kuroko_codec, ByteCatenator, StringCatenator, UnicodeEncodeError, UnicodeDecodeError, lookup_error
from codecs.dbdata import encode_jis7, decode_jis7, decode_jis7katakana, encode_gbk, decode_gbk, gb_surrogate_ranges
from itertools import enumerate

class Gb18030IncrementalEncoder:
    name = "gb18030"
    webname = "gb18030"
    four_byte_codes = True
    def __init__(errors):
        self.errors = errors
    def encode(string, final = False):
        let out = ByteCatenator()
        let offset = 0
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(string):
                return out.getvalue()
            let i = string[offset]
            if ord(i) < 0x80:
                out.add(bytes([ord(i)]))
                offset += 1
            else if (not self.four_byte_codes) and (ord(i) == 0x20AC):
                out.add(b"\x80")
                offset += 1
            else if ord(i) in encode_gbk:
                let target = encode_gbk[ord(i)]
                if isinstance(target, tuple):
                    for individ in target:
                        out.add(bytes([individ]))
                else:
                    out.add(bytes([target]))
                offset += 1
            else if (not self.four_byte_codes) or (ord(i) == 0xE5E5):
                let error = UnicodeEncodeError(self.name, string, offset, offset + 1, "")
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
            else:
                let pointer
                if ord(i) == 0xE7C7:
                    pointer = 7457
                else:
                    let basepointer = 0
                    let basecodepoint = 0
                    for nexttuple in gb_surrogate_ranges:
                        let nextpointer = nexttuple[0]
                        let nextcodepoint = nexttuple[1]
                        if nextcodepoint > ord(i):
                            break
                        basepointer = nextpointer
                        basecodepoint = nextcodepoint
                    pointer = (ord(i) - basecodepoint) + basepointer
                let running = pointer
                let first = 0x81 + (running / (10 * 126 * 10))
                running %= 10 * 126 * 10
                let second = 0x30 + (running / (10 * 126))
                running %= 10 * 126
                let third = 0x81 + (running / 10)
                let fourth = 0x30 + (running % 10)
                out.add(bytes([first, second, third, fourth]))
                offset += 1
    def reset():
    def getstate():
        return 0
    def setstate(state):
        if state != 0:
            raise ValueError("stateless encoder being set to nonzero state")

class GbkIncrementalEncoder(Gb18030IncrementalEncoder):
    name = "gbk"
    webname = "gbk"
    four_byte_codes = False

def _get_gbsurrogate_pointer(leader, i):
    let ret = (leader[0] - 0x81) * (10 * 126 * 10)
    ret += (leader[1] - 0x30) * (10 * 126)
    ret += (leader[2] - 0x81) * 10
    ret += i - 0x30
    if (39419 < ret and ret < 189000) or (ret > 1237575): return None
    return ret

class Gb18030IncrementalDecoder:
    name = "gb18030"
    webname = "gb18030"
    def __init__(errors):
        self.errors = errors
    def decode(data, final = False):
        let out = StringCatenator()
        let offset = 0
        let leader = []
        let bytemode = 1
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(data):
                if bytemode == 1:
                    return out.getvalue()
                else:
                    let error = UnicodeDecodeError(self.name, data, offset - len(leader), offset, "")
                    let errorret = lookup_error(self.errors)(error)
                    out.add(errorret[0])
                    return out.getvalue()
            let i = data[offset]
            if bytemode == 1 and i < 0x80:
                out.add(chr(i))
                offset += 1
            else if bytemode == 1 and (0x81 <= i and i <= 0xFE):
                bytemode = 2
                leader.append(i)
                offset += 1
            else if bytemode == 1 and i in self.decoding_map:
                out.add(chr(self.decoding_map[i]))
                offset += 1
            else if bytemode == 2 and (leader[0], i) in decode_gbk:
                out.add(chr(decode_gbk[(leader[0], i)]))
                offset += 1
                bytemode = 1
                leader = []
            else if bytemode == 2 and (0x30 <= i and i <= 0x39):
                bytemode = 4
                leader.append(i)
                offset += 1
            else if bytemode == 4 and len(leader) == 2 and (0x81 <= i and i <= 0xFE):
                leader.append(i)
                offset += 1
            else if bytemode == 4 and len(leader) == 3 and _get_gbsurrogate_pointer(leader, i):
                let pointer = _get_gbsurrogate_pointer(leader, i)
                let codepoint
                if pointer == 7457:
                    codepoint = 0xE7C7
                else:
                    let basecodepoint = 0
                    let basepointer = 0
                    for nexttuple in gb_surrogate_ranges:
                        let nextpointer = nexttuple[0]
                        let nextcodepoint = nexttuple[1]
                        if nextpointer > pointer:
                            break
                        basecodepoint = nextcodepoint
                        basepointer = nextpointer
                    codepoint = (pointer - basepointer) + basecodepoint
                out.add(chr(codepoint))
                offset += 1
                bytemode = 1
                leader = []
            else:
                let errorstart = offset - len(leader)
                let errorend = errorstart + bytemode
                # Note: per WHATWG behaviour, if an invalid multi-byte code contains an ASCII byte,
                #   parsing shall resume at that byte.
                if bytemode > 1:
                    if len(leader) > 1:
                        errorend -= 3
                    else if i < 0x80:
                        errorend -= 1
                let error = UnicodeDecodeError(self.name, data, errorstart, errorend, "")
                bytemode = 1
                leader = []
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
    def reset():
    def getstate():
        return 0
    def setstate(state):
        if state != 0:
            raise ValueError("stateless decoder being set to nonzero state")

register_kuroko_codec(
    ["gb18030", "chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80",
     "gbk", "iso-ir-58", "x-gbk"], None, Gb18030IncrementalDecoder)
register_kuroko_codec(["gb18030"], Gb18030IncrementalEncoder, None)
register_kuroko_codec(
    ["chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80",
     "gbk", "iso-ir-58", "x-gbk"], GbkIncrementalEncoder, None)

class Iso2022JpIncrementalEncoder:
    name = "iso-2022-jp" # arguably should call it summat else since it's not exactly RFC 1468
    webname = "iso-2022-jp"
    encmap_jis7 = encode_jis7
    # eager: switch to a lower numbered state when possible (à la Python)
    # lazy: switch state only when necessary (à la WHATWG)
    attitude = "lazy"
    # state values:
    # — 0: ASCII
    # — 1: JIS-Roman
    # — 2: JIS-Kanji
    state = None
    def __init__(errors):
        self.errors = errors
        self.state = 0
    def ensure_state_number(state, out):
        if self.state == state:
        else if state == 0:
            out.add(b"\x1B(B")
        else if state == 1:
            out.add(b"\x1B(J")
        else if state == 2:
            out.add(b"\x1B$B")
        else:
            raise ValueError("set to invalid state: " + repr(state))
        self.state = state
    def encode(string, final = False):
        let out = ByteCatenator()
        let offset = 0
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(string):
                if final:
                    self.ensure_state_number(0, out)
                return out.getvalue()
            let i = string[offset]
            let is_ascii = ord(i) < 0x80
            let is_jiscii = (is_ascii and i not in "\\~") or (i in "¥\u203E")
            let is_jis7 = ord(i) in self.encmap_jis7
            let is_sets = [is_ascii, is_jiscii, is_jis7]
            if (not is_sets[self.state]) or (self.attitude == "eager"):
                for n, j in enumerate(is_sets):
                    if j:
                        self.ensure_state_number(n, out)
                        break
            if not is_sets[self.state]: # i.e. still isn't.
                let error = UnicodeEncodeError(self.name, string, offset, offset + 1, "")
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
            else if self.state in [0, 1]:
                # By this point we know whether ASCII or JIS-Roman is appropriate and have switched
                #   to the appropriate one, so we can just treat these the same now.
                let j
                if i == "¥":
                    j = "\\"
                else if i == "\u203E":
                    j = "~"
                else:
                    j = i
                out.add(bytes([ord(j)]))
                offset += 1
            else:
                for individ in self.encmap_jis7[ord(i)]:
                    out.add(bytes([individ]))
                offset += 1
    def reset():
        self.state = 0
    def getstate():
        return self.state
    def setstate(state):
        if state not in [0, 1, 2]:
            raise ValueError("invalid state: " + repr(state))
        self.state = state

class Iso2022JpIncrementalDecoder:
    name = "iso-2022-jp" # arguably should call it summat else since it's not exactly RFC 1468
    webname = "iso-2022-jp"
    decmap_jis7 = decode_jis7
    decmap_jis7katakana = decode_jis7katakana
    # eager: switch to a lower numbered state when possible (à la Python)
    # lazy: switch state only when necessary (à la WHATWG)
    attitude = "lazy"
    # state values:
    # — 0: ASCII
    # — 1: JIS-Roman
    # — 2: JIS-Kanji
    # — 3: JIS-Katakana
    state = None
    def __init__(errors):
        self.errors = errors
    def decode(data, final = False):
        let out = StringCatenator()
        let offset = 0
        let leader = []
        let bytemode = 1
        if self.state == 2:
            bytemode = 2
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(data):
                if bytemode in (1, 2):
                    return out.getvalue()
                else:
                    let error = UnicodeDecodeError(self.name, data, offset - len(leader), offset, "")
                    let errorret = lookup_error(self.errors)(error)
                    out.add(errorret[0])
                    return out.getvalue()
            let i = data[offset]
            if i == 0x1B and len(leader) == 0:
                bytemode = 3
                leader.append(i)
                offset += 1
            else if bytemode == 3 and len(leader) == 1 and i in (0x24, 0x28):
                leader.append(i)
                offset += 1
            else if bytemode == 3 and len(leader) == 2 and leader[1] == 0x28 and i == 0x42:
                self.state = 0
                bytemode = 1
                leader = []
                offset += 1
            else if bytemode == 3 and len(leader) == 2 and leader[1] == 0x28 and i == 0x4A:
                self.state = 1
                bytemode = 1
                leader = []
                offset += 1
            else if bytemode == 3 and len(leader) == 2 and leader[1] == 0x24 and i in (0x40, 0x42):
                self.state = 2
                bytemode = 2
                leader = []
                offset += 1
            else if bytemode == 3 and len(leader) == 2 and leader[1] == 0x28 and i == 0x49:
                self.state = 3
                bytemode = 1
                leader = []
                offset += 1
            else if bytemode == 2 and len(leader) == 0:
                leader.append(i)
                offset += 1
            else if bytemode == 1 and self.state == 0 and i < 0x80:
                out.add(chr(i))
                offset += 1
            else if bytemode == 1 and self.state == 1 and i < 0x80:
                let char = chr(i)
                if char == "\\":
                    char = "¥"
                else if char == "~":
                    char = "\u203E"
                out.add(char)
                offset += 1
            else if bytemode == 1 and i in self.decmap_jis7katakana:
                out.add(chr(self.decmap_jis7katakana[i]))
                offset += 1
            else if bytemode == 2 and (leader[0], i) in self.decmap_jis7:
                out.add(chr(self.decmap_jis7[(leader[0], i)]))
                offset += 1
                leader = []
            else:
                let errorstart = offset - len(leader)
                let errorend
                if bytemode == 2 and i != 0x1B:
                    errorend = errorstart + 2
                else:
                    errorend = errorstart + 1
                let error = UnicodeDecodeError(self.name, data, errorstart, errorend, "")
                bytemode = 1
                leader = []
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
    def reset():
        self.state = 0
    def getstate():
        return self.state
    def setstate(state):
        if state not in [0, 1, 2, 3]:
            raise ValueError("invalid state: " + repr(state))
        self.state = state

register_kuroko_codec(["iso-2022-jp", "csiso2022jp"],
    Iso2022JpIncrementalEncoder, Iso2022JpIncrementalDecoder)



