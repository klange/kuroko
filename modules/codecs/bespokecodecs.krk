from codecs.infrastructure import register_kuroko_codec, ByteCatenator, StringCatenator, UnicodeEncodeError, UnicodeDecodeError, lookup_error
from codecs.dbdata import encode_jis7, decode_jis7, decode_jis7katakana, encode_gbk, decode_gbk, gb_surrogate_ranges

class Gb18030IncrementalEncoder:
    name = "gb18030"
    webname = "gb18030"
    four_byte_codes = True
    def __init__(errors):
        self.errors = errors
    def encode(string, final = False):
        let out = ByteCatenator()
        let offset = 0
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(string):
                return out.getvalue()
            let i = string[offset]
            if ord(i) < 0x80:
                out.add(bytes([ord(i)]))
                offset += 1
            else if (not self.four_byte_codes) and (ord(i) == 0x20AC):
                out.add(b"\x80")
                offset += 1
            else if ord(i) in encode_gbk:
                let target = encode_gbk[ord(i)]
                if isinstance(target, tuple):
                    for individ in target:
                        out.add(bytes([individ]))
                else:
                    out.add(bytes([target]))
                offset += 1
            else if (not self.four_byte_codes) or (ord(i) == 0xE5E5):
                let error = UnicodeEncodeError(self.name, string, offset, offset + 1, "")
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
            else:
                let pointer
                if ord(i) == 0xE7C7:
                    pointer = 7457
                else:
                    let basepointer = 0
                    let basecodepoint = 0
                    for nexttuple in gb_surrogate_ranges:
                        let nextpointer = nexttuple[0]
                        let nextcodepoint = nexttuple[1]
                        if nextcodepoint > ord(i):
                            break
                        basepointer = nextpointer
                        basecodepoint = nextcodepoint
                    pointer = (ord(i) - basecodepoint) + basepointer
                let running = pointer
                let first = 0x81 + (running / (10 * 126 * 10))
                running %= 10 * 126 * 10
                let second = 0x30 + (running / (10 * 126))
                running %= 10 * 126
                let third = 0x81 + (running / 10)
                let fourth = 0x30 + (running % 10)
                out.add(bytes([first, second, third, fourth]))
                offset += 1
    def reset():
    def getstate():
        return 0
    def setstate(state):
        if state != 0:
            raise ValueError("stateless encoder being set to nonzero state")

class GbkIncrementalEncoder(Gb18030IncrementalEncoder):
    name = "gbk"
    webname = "gbk"
    four_byte_codes = False

def _get_gbsurrogate_pointer(leader, i):
    let ret = (leader[0] - 0x81) * (10 * 126 * 10)
    ret += (leader[1] - 0x30) * (10 * 126)
    ret += (leader[2] - 0x81) * 10
    ret += i - 0x30
    if (39419 < ret and ret < 189000) or (ret > 1237575): return None
    return ret

class Gb18030IncrementalDecoder:
    name = "gb18030"
    webname = "gb18030"
    def __init__(errors):
        self.errors = errors
    def decode(data, final = False):
        let out = StringCatenator()
        let offset = 0
        let leader = []
        let bytemode = 1
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(data):
                if bytemode == 1:
                    return out.getvalue()
                else:
                    let error = UnicodeDecodeError(self.name, data, offset - len(leader), offset + 1, "")
                    let errorret = lookup_error(self.errors)(error)
                    out.add(errorret[0])
                    return out.getvalue()
            let i = data[offset]
            if bytemode == 1 and i < 0x80:
                out.add(chr(i))
                offset += 1
            else if bytemode == 1 and (0x81 <= i and i <= 0xFE):
                bytemode = 2
                leader.append(i)
                offset += 1
            else if bytemode == 1 and i in self.decoding_map:
                out.add(chr(self.decoding_map[i]))
                offset += 1
            else if bytemode == 2 and (leader[0], i) in decode_gbk:
                out.add(chr(decode_gbk[(leader[0], i)]))
                offset += 1
                bytemode = 1
                leader = []
            else if bytemode == 2 and (0x30 <= i and i <= 0x39):
                bytemode = 4
                leader.append(i)
                offset += 1
            else if bytemode == 4 and len(leader) == 2 and (0x81 <= i and i <= 0xFE):
                leader.append(i)
                offset += 1
            else if bytemode == 4 and len(leader) == 3 and _get_gbsurrogate_pointer(leader, i):
                let pointer = _get_gbsurrogate_pointer(leader, i)
                let codepoint
                if pointer == 7457:
                    codepoint = 0xE7C7
                else:
                    let basecodepoint = 0
                    let basepointer = 0
                    for nexttuple in gb_surrogate_ranges:
                        let nextpointer = nexttuple[0]
                        let nextcodepoint = nexttuple[1]
                        if nextpointer > pointer:
                            break
                        basecodepoint = nextcodepoint
                        basepointer = nextpointer
                    codepoint = (pointer - basepointer) + basecodepoint
                out.add(chr(codepoint))
                offset += 1
                bytemode = 1
                leader = []
            else:
                let errorstart = offset + 1 - bytemode
                let errorend = errorstart + bytemode
                # Note: per WHATWG behaviour, if an invalid multi-byte code contains an ASCII byte,
                #   parsing shall resume at that byte.
                if bytemode > 1:
                    if len(leader) > 1:
                        errorend -= 3
                    else if i < 0x80:
                        errorend -= 1
                let error = UnicodeDecodeError(self.name, data, errorstart, errorend, "")
                bytemode = 1
                leader = []
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)
    def reset():
    def getstate():
        return 0
    def setstate(state):
        if state != 0:
            raise ValueError("stateless decoder being set to nonzero state")

register_kuroko_codec(
    ["gb18030", "chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80",
     "gbk", "iso-ir-58", "x-gbk"], None, Gb18030IncrementalDecoder)

register_kuroko_codec(["gb18030"], Gb18030IncrementalEncoder, None)
register_kuroko_codec(
    ["chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80",
     "gbk", "iso-ir-58", "x-gbk"], GbkIncrementalEncoder, None)





