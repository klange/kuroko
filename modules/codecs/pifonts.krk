"""
This module includes codecs implementing special handling for symbol fonts.
"""

from codecs.dbextra_data_8bit import data_8bit
from codecs.dbextra_data_7bit import data_7bit

from codecs.infrastructure import register_kuroko_codec, ByteCatenator, StringCatenator, UnicodeEncodeError, UnicodeDecodeError, lookup_error, lookup, IncrementalEncoder, IncrementalDecoder, lazy_property
from collections import xraydict

class Cp042IncrementalEncoder(IncrementalEncoder):
    """
    Encoder for Windows code page 42, and base class for symbol font encoders.

    This maps characters to PUA with the low 8 bits matching the original byte encoding, similarly
    to `x-user-defined`, but using a different PUA range and including all non-C0 bytes, not
    only non-ASCII bytes.
    """
    name = "cp042"
    html5name = None
    @lazy_property
    def encoding_map():
        return {i + 0xF000 : i for i in range(0x20, 0x100)}
    def encode(string_in, final = False):
        """Implements `IncrementalEncoder.encode`"""
        let out = ByteCatenator()
        let offset = 0
        while 1: # offset can be arbitrarily changed by the error handler, so not a for
            if offset >= len(string):
                return out.getvalue()
            let i = string[offset]
            if ord(i) < 0x20:
                out.add(bytes([ord(i)]))
                offset += 1
            else if ord(i) in self.encoding_map:
                let target = self.encoding_map[ord(i)]
                out.add(bytes([target]))
                offset += 1
            else:
                let error = UnicodeEncodeError(self.name, string, offset, offset + 1,
                            "character not supported by target encoding")
                let errorret = lookup_error(self.errors)(error)
                out.add(errorret[0])
                offset = errorret[1]
                if offset < 0:
                    offset += len(string)

class Cp042IncrementalDecoder(IncrementalDecoder):
    """
    Decoder for Windows code page 42, and base class for symbol font decoders.

    This maps characters to PUA with the low 8 bits matching the original byte encoding, similarly
    to `x-user-defined`, but using a different PUA range and including all non-C0 bytes, not
    only non-ASCII bytes.
    """
    name = "cp042"
    html5name = None
    decoding_map = {}
    def decode(data, final = False):
        """Implements `IncrementalDecoder.decode`"""
        self.pending = b""
        let out = StringCatenator()
        let offset = 0
        for i in data:
            if i < 0x20:
                out.add(chr(i))
            else if i in self.decoding_map:
                out.add(chr(self.decoding_map[i]))
            else:
                out.add(chr(i + 0xF000))
        return out.getvalue()

register_kuroko_codec(["cp042"], Cp042IncrementalEncoder, Cp042IncrementalDecoder)



