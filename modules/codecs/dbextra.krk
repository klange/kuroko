"""
This module includes some additional variable-width or wide encodings not specified by WHATWG. As 
such, none of the codecs in this module should be used in HTML.
"""

from codecs.extradata import encmap_lat1supp, decmap_lat1supp, encmap_greksupp, decmap_greksupp, encmap_jis78, decmap_jis78, encmap_jis90p2, decmap_jis90p2, encmap_jis00, decmap_jis00, encmap_jis00p2, decmap_jis00p2, encmap_jis04, decmap_jis04, encmap_jis7katakana, encmap_gb7, decmap_gb7, encmap_ksc7, decmap_ksc7, encmap_nbyte_ebcdic, decmap_nbyte_ebcdic, encmap_johab_hangul, decmap_johab_hangul, encmap_johabx_ascii, decmap_johabx_ascii, encmap_johabx_ebcdic, decmap_johabx_ebcdic
from codecs.infrastructure import register_kuroko_codec, ByteCatenator, StringCatenator, UnicodeEncodeError, UnicodeDecodeError, lookup_error, lookup, BaseEbcdicIncrementalEncoder, BaseEbcdicIncrementalDecoder, AsciiIncrementalEncoder, AsciiIncrementalDecoder
from codecs.dbdata import encode_jis7, decode_jis7, decode_jis7katakana
from codecs.bespokecodecs import Iso2022JpIncrementalEncoder, Iso2022JpIncrementalDecoder

let encmap_johab_ascii = encmap_johabx_ascii.copy()
encmap_johab_ascii.update(encmap_johab_hangul)
class AsciiJohabIncrementalEncoder(AsciiIncrementalEncoder):
    name = "johab-ascii"
    html5name = None
    encoding_map = encmap_johab_ascii

let decmap_johab_ascii = decmap_johabx_ascii.copy()
decmap_johab_ascii.update(decmap_johab_hangul)
class AsciiJohabIncrementalDecoder(AsciiIncrementalDecoder):
    name = "johab-ascii"
    html5name = None
    decoding_map = decmap_johab_ascii
    dbrange = tupleOf(*range(0x84, 0xF9 + 1))
    # Trail ranges for hangul and nonhangul are different, but this is their union.
    trailrange = tupleOf(*range(0x31, 0x7E + 1), *range(0x81, 0xFE + 1))

register_kuroko_codec(["cp1361", "ms1361", "johab", "x-johab", "johab-ascii"],
    AsciiJohabIncrementalEncoder, AsciiJohabIncrementalDecoder)


let encmap_johab_ebcdic = encmap_johabx_ebcdic.copy()
encmap_johab_ebcdic.update(encmap_johab_hangul)
class EbcdicJohabIncrementalEncoder(BaseEbcdicIncrementalEncoder):
    name = "johab-ebcdic"
    html5name = None
    sbcs_encmap = encmap_nbyte_ebcdic
    dbcshost_encmap = encmap_johab_ebcdic

let decmap_johab_ebcdic = decmap_johabx_ebcdic.copy()
decmap_johab_ebcdic.update(decmap_johab_hangul)
class EbcdicJohabIncrementalDecoder(BaseEbcdicIncrementalDecoder):
    name = "johab-ebcdic"
    html5name = None
    sbcs_decmap = decmap_nbyte_ebcdic
    dbcshost_decmap = decmap_johab_ebcdic

register_kuroko_codec(["cp933", "ibm-933", "933", "x-IBM933", "johab-ebcdic"],
    EbcdicJohabIncrementalEncoder, EbcdicJohabIncrementalDecoder)


class JisEncodingIncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "jis_encoding"
    html5name = None
    encmaps_sbcs = [None, None, encmap_jis7katakana]
    encmaps_dbcs = [None, None, None, encode_jis7, encmap_jis78, encmap_jis90p2,
                    encmap_jis00, encmap_jis00p2, encmap_jis04, encmap_gb7, encmap_ksc7]
    encmap_supershift_latin = encmap_lat1supp
    encmap_supershift_greek = encmap_greksupp
    super_shift = True
    escs_onebyte = {0: 0x42, 1: 0x4A, 2: 0x49}
    escs_twobyte = {3: 0x42, 4: 0x40, 5: 0x44, 6: 0x4F, 7: 0x50, 8: 0x51, 9: 0x41, 10: 0x43}
    attitude = "eager"

class JisEncodingIncrementalDecoder(Iso2022JpIncrementalDecoder):
    name = "jis_encoding"
    html5name = None
    decmaps_sbcs = [None, None, decode_jis7katakana]
    decmaps_dbcs = [None, None, None, decode_jis7, decmap_jis78, decmap_jis90p2,
                    decmap_jis00, decmap_jis00p2, decmap_jis04, decmap_gb7, decmap_ksc7]
    decmap_shiftout = decode_jis7katakana
    decmap_supershift_latin = decmap_lat1supp
    decmap_supershift_greek = decmap_greksupp
    # 0x48 is not ASCII or JIS-Roman, but SEN 85 02 00 Annex C. It is however misused for either
    #   ASCII or JIS-Roman in some encoders, so it is a "good idea for software to recognise,
    #   but not to generate" (â€”Lunde) it for JIS-Roman when decoding JIS_encoding.
    escs_onebyte = {0x42: 0, 0x48: 1, 0x49: 2, 0x4A: 1}
    escs_twobyte = {0x40: 4, 0x41: 9, 0x42: 3, 0x43: 10, 0x44: 5, 0x4F: 6, 0x50: 7, 0x51: 8}
    two_byte_modes = [3, 4, 5, 6, 7, 8, 9, 10]
    new_twobytes = True
    shift_out = True
    super_shift = True

register_kuroko_codec(["jis_encoding", "csjisencoding", "jis", "jis7"],
    JisEncodingIncrementalEncoder, JisEncodingIncrementalDecoder)


class Iso2022Jp1IncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "iso-2022-jp-1"
    html5name = None
    encmaps_sbcs = [None, None]
    encmaps_dbcs = [None, None, encmap_jis90p2, encode_jis7]
    escs_onebyte = {0: 0x42, 1: 0x4A}
    escs_twobyte = {3: 0x42, 2: 0x44}
    attitude = "eager"

register_kuroko_codec(["iso-2022-jp-1"],
    Iso2022Jp1IncrementalEncoder, JisEncodingIncrementalDecoder)


class Iso2022JpExtIncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "iso-2022-jp-ext"
    html5name = None
    encmaps_sbcs = [None, None, encmap_jis7katakana]
    encmaps_dbcs = [None, None, None, encmap_jis90p2, encode_jis7]
    escs_onebyte = {0: 0x42, 1: 0x4A, 2: 0x49}
    escs_twobyte = {4: 0x42, 3: 0x44}
    attitude = "eager"

register_kuroko_codec(["iso-2022-jp-ext"],
    Iso2022JpExtIncrementalEncoder, JisEncodingIncrementalDecoder)


class Iso2022Jp2IncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "iso-2022-jp-2"
    html5name = None
    encmaps_sbcs = [None, None]
    encmaps_dbcs = [None, None, encmap_jis90p2, encode_jis7, encmap_gb7, encmap_ksc7]
    encmap_supershift_latin = encmap_lat1supp
    encmap_supershift_greek = encmap_greksupp
    super_shift = True
    escs_onebyte = {0: 0x42, 1: 0x4A}
    escs_twobyte = {3: 0x42, 2: 0x44, 4: 0x41, 5: 0x43}
    attitude = "eager"

register_kuroko_codec(["iso-2022-jp-2", "csISO2022JP2"],
    Iso2022Jp2IncrementalEncoder, JisEncodingIncrementalDecoder)


# Bit confusing to explain what this bit is doing, so let me explain:
#   The JIS X 0213 variants of ISO-2022-JP should encode to JIS X 0213 before encoding to any
#   extension to JIS X 0208 (assuming they "should" encode to extensions at all). So we remove any
#   characters that are encoded to different locations in JIS X 0213. This also removes certain
#   Unicode characters that are mapped differently by Microsoft/WHATWG versus by JIS X 0213 (e.g.
#   Microsoft mapping the Unicode fullwidth tilde to the JIS wave dash, while JIS X 0213 includes
#   it separately and maps the JIS wave dash to the Unicode wave dash), forcing them to be encoded
#   to JIS X 0213.
let encode_jis7_reduced = {}
for i in encode_jis7.keys():
    if (i not in encmap_jis00 or encmap_jis00[i] == encode_jis7[i]) and (i not in encmap_jis00p2):
        encode_jis7_reduced[i] = encode_jis7[i]


class Iso2022Jp3IncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "iso-2022-jp-3"
    html5name = None
    encmaps_sbcs = [None, None, encmap_jis7katakana]
    encmaps_dbcs = [None, None, None, encode_jis7_reduced, encmap_jis00, encmap_jis00p2]
    escs_onebyte = {0: 0x42, 1: 0x4A, 2: 0x49}
    escs_twobyte = {3: 0x42, 4: 0x4F, 5: 0x50}
    attitude = "eager"

register_kuroko_codec(["iso-2022-jp-3"],
    Iso2022Jp3IncrementalEncoder, JisEncodingIncrementalDecoder)


class Iso2022Jp2004IncrementalEncoder(Iso2022JpIncrementalEncoder):
    name = "iso-2022-jp-2004"
    html5name = None
    encmaps_sbcs = [None, None, encmap_jis7katakana]
    encmaps_dbcs = [None, None, None, encode_jis7_reduced, encmap_jis00p2, encmap_jis04]
    escs_onebyte = {0: 0x42, 1: 0x4A, 2: 0x49}
    escs_twobyte = {3: 0x42, 4: 0x50, 5: 0x51}
    attitude = "eager"

register_kuroko_codec(["iso-2022-jp-2004"],
    Iso2022Jp2004IncrementalEncoder, JisEncodingIncrementalDecoder)






